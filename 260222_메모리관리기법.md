### 메모리란?

메인메모리, RAM을 뜻함. 프로그램 실행 시 필요한 주소, 정보들을 저장하고 가져다 사용할 수 있게 만드는 공간

### 관리가 필요한 이유?

- 각각의 프로세스는 독립된 메모리 공간을 갖음 → 다른 프로세스 접근 X
- 유일하게 운영체제만이 접근의 제약을 받지 않음→ 운영체제가 관리
- 멀티프로그래밍 환경으로 변화하면서 메모리를 효율적으로 써야함 → 관리 방법이 중요해짐
- 운영체제의 역할
    
    실행 파일이 로더에 의해 메모리에 올라오고, 운영체제는 이 실행파일을 메모리에 어느부분에 올릴지 결정함
    

## Swapping

메모리에 적재되어 있으나, 현재 사용되지 않고 있는 프로세스를 관리하는 역할

- 표준 : 라운드 로빈 같은 선점 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 backing store로 보내고 다른 프로세스의 메모리를 불러들임

→ 이 과정을 스왑이라고 한다. RAM으로 불러오는 과정은 swap-in, backing store로 내보내는 과정을 swap-out이라 한다.

<aside>

현재는 메모리 공간이 부족할 때 Swapping을 한다.

</aside>

### 단편화 현상

메모리의 공간이 작은 조각으로 나뉘어서, 사용 가능한 메모리가 충분히 있는데도 불구하고 할당하지 못하는 상태

1. 내부 단편화 - 프로세스가 사용하는 메모리 공간에 포함된 남는 부분
2. 외부 단편화 - 메모리 공간 중 사용하지 못하게 되는 일부분
3. 압축 - 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아, 자유 공간을 확보하는 방법론 (효율이 그닥 좋진 않음)

## 메모리 관리 방법

위의 단편화 현상을 줄이고 적절한 swap을 통해 효율적으로 메모리를 관리하기 위한 방법

1. **연속 메모리 할당** - 메모리에 연속적으로 할당하는 것임(외부 단편화 해결 X)
    1. 최초 적합(first fit) : 가장 처음 만나는 빈 메모리 공간에 할당
    2. 최적 적합(best fit) : 빈 메모리 공간의 크기와 프로세스 크기차이가 가장 적은 곳에 할당
    3. 최악 적합(worst fit) : 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 큰 곳에 프로세스를 할당 (이렇게 생긴 빈 공간에 또다른 프로세스를 할당할 수 있을 거라 가정)
2. **페이징 기법** - 가상메모리를 사용하여 외부 단편화 해결(내부 단편화 X)
    - 메모리 공간이 연속적이어야 한다는 제약을 없애는 방법
    - 물리 메모리는 frame이라는 고정 크기로 분리되어 있고, 논리메모리는 page라는 고정크기의 블록으로 분리됨
    - 하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어서 관리되고, 개별 페이지는 순서에 상관없이 물리메모리에 있는 프레임에 mapping되어 저장됨
    - 예시 : 4KB 짜리로 나뉜 공간에 14KB 프로세스 할당 → 공간 4개 활용, 2KB가 남아 내부 단편화 발생
    1. **세그먼테이션** - 가상 메모리 사용, 내부단편화 해결(외부 단편화 X)
        1. 페이징처럼 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트로 분할하여 사용자가 두개의 주소로 지정함
        2. 세그먼트 테이블에는 각 세그먼트의 기준(시작 물리주소)과 한계(세그먼트 길이)를 저장함
        3. 단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되면, 자유 공간을이 많은 수의 작은 조각들로 나누어져 못쓸수도 있음
    2. **메모리 풀**
        - 필요한 메모리 공간을 필요한 크기, 개수만큼 사용자가 직접 지정하여 미리 할당 받아놓고 필요할 떄마다 사용하고 반납하는 기법
        - 장점 : 미리 공간을 할당해놓고 가져다 쓰고 반납하여 외부단편화, 내부단편화 둘 다 생기지 않음
        - 단점 : 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들어놓고 쓰지 않을 때의 메모리 양이 커진다면 사용하지 않아야함
        - 메모리의 할당, 해제가 잦은 경우에 효과적임
